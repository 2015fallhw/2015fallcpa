Title: 2015 計算機程式 第17週
Date: 2016-01-09
Category: Python
Tags: pelican, publishing
Slug: 2015cp_hw_w17
Authors: coursemdetw
Summary: 作業一摘要


<iframe src="40423104_cp_w17_p.html" width="500" height="300"></iframe>

程式語言架構
            
1.程式網頁 → 直接呼叫在網路上的 javascript ， Brython 其實是透過 javascript ，讓我們可以寫 Python 格式，與許此程式在網路上執行。            
 2.以下圖示為利用Python來執行網頁的必要條件          
 <a href="http://imgur.com/MRowviB"><img src="http://i.imgur.com/MRowviB.jpg" title="source: imgur.com" /></a>      
 3.canvas → 需要設定 ID ，屬於 html (也就是超文件)，在後面設定畫佈大小。    
 4.browser 模組中的 document, 並設為 doc 變數 → Brython特有的    
5.導入數學模組(import math)           
6.產生各小球的亂數速度用 (import random)→ 讓每一個小球初始速度是亂數    
7.導入 browser 中的計時器, 建立動畫用(import browser.timer) → 每隔一個時間，要重新刷新螢幕。       
8.利用迴圈產生初始速度        
9.random.random() 將會產生介於 0 與 1 的浮點亂數 → 速度使用此方式設置        
10.透過更新第 i 球 Y 座標的運算邏輯 → 進行運算           
11.透過更新第 i 球 X 座標的運算邏輯 → 進行運算           
12.設定圓的程式           
13.每隔特定時間, 進行動畫繪製 → 依我們14.畫布點擊後執行的函式        
15.只要使用者點擊在畫布上任何地方, 即執行 on_canvas_click 函式 → bind為連結        


<!-- 導入 brython.js -->

<script type="text/javascript" src="http://brython.info/src/brython_dist.js"></script>

<!-- 啟動 brython() -->

<script>
window.onload=function(){
brython(1);
}
</script>

<!-- 以下利用 Brython 程式執行繪圖 -->

<canvas id="plotarea" width="600" height="400"></canvas>

<script type="text/python3">
# 導入 browser 模組中的 document, 並設為 doc 變數
from browser import document as doc
# 導入數學模組
import math
# 產生各小球的亂數速度用
import random
# 導入 browser 中的計時器, 建立動畫用
import browser.timer

# 準備繪圖畫布
canvas = doc["plotarea"]
ctx = canvas.getContext("2d")

# 取畫布的寬與高度
width = canvas.width
height = canvas.height

n = 30
# 已知數列內容個數, 先分別與 None 對應
x = [None]*n
y = [None]*n
vy = [None]*n
vx = [None]*n
# 重力加速度, Y 方向向下為正
g = 0.05
# 空氣的黏滯阻尼係數
cor = 0.7 
# 球的彈力係數
fr = 0.95
# 球的半徑
r = 3

for i in range(n):
    x[i] = 300
    y[i] = 100
    # random.random() 將會產生介於 0 與 1 的浮點亂數
    vx[i] = 2*(random.random()-.5)
    vy[i] = 2*(random.random()-.5)

# 更新第 i 球 Y 座標的運算邏輯
def updateY(i):
    if ((y[i]+r) < height):
        #y = height
        vy[i] += g
    else:
        vy[i] = -vy[i]*cor
        vx[i] *= fr
    y[i] += vy[i]
    if ((y[i]+r) > height):
        y[i] = height-r

# 更新第 i 球 X 座標的運算邏輯
def updateX(i):
    if ((x[i]+r) >= width or (x[i]-r) <= 0):
        vx[i] = -vx[i]*cor
    x[i] += vx[i]
    if ((x[i]+r) > width):
        x[i] = width-r
    elif ((x[i]-r) < 0):
        x[i] = r

# 畫圓函式
def circle(x,y,r):
    ctx.beginPath()
    ctx.arc(x, y, r, 0, math.pi*2, True)
    ctx.fill()

# 寫字函式
def text(s):
    ctx.fillStyle = "#ff0000"
    ctx.font = "30px sans-serif"
    ctx.textBaseline = "bottom"
    ctx.fillText(s,0,height)

# 每隔特定時間, 進行動畫繪製
def animate():
    # 刷新畫布
    ctx.clearRect(0, 0, width, height)
    # 逐一重新繪製小球
    ctx.fillStyle = "#000000"
    for i in range(n):
        updateY(i)
        updateX(i)
        circle(x[i],y[i],r)

text("Click me!")

# 畫布點擊後執行的函式
def on_canvas_click(ev):
    browser.timer.set_interval(animate,0)

# 只要使用者點擊在畫布上任何地方, 即執行 on_canvas_click 函式
canvas.bind('click', on_canvas_click, False)
</script>